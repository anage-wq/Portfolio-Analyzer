# -*- coding: utf-8 -*-
"""Portfolio_xirr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XRRX8VSpYPnDtU7OBiOJRkO-JSw0YxnJ
"""

import pandas as pd
import yfinance as yf
from datetime import date
from scipy.optimize import newton
import json
import warnings

warnings.filterwarnings('ignore', category=FutureWarning)  # Suppress pandas concat warnings


class DataPreprocessor:
    """Single Responsibility: Preprocess raw trade data."""
    def __init__(self, dataframe):
        self.df = dataframe

    def preprocess(self):
        self.df = self.df.drop(['Segment', 'Series', 'Auction', 'Trade ID', 'Order ID', 'Order Execution Time'], axis=1, errors='ignore')
        self.df['Trade Type'] = self.df['Trade Type'].str.lower()
        self.df['Trade Date'] = pd.to_datetime(self.df['Trade Date'], dayfirst=True, errors='coerce', format='mixed').dt.tz_localize(None)
        self.df['Quantity'] = pd.to_numeric(self.df['Quantity'].astype(str).str.replace(',', '', regex=False), errors='coerce')
        self.df['Price'] = pd.to_numeric(self.df['Price'].astype(str).str.replace(',', '', regex=False), errors='coerce')
        return self.df


class SymbolResolver:
    """Single Responsibility: Resolve symbol ambiguity."""
    def __init__(self, dataframe):
        self.df = dataframe.copy()

    def is_delisted(self, symbol, suffix):
        try:
            ticker = yf.Ticker(symbol + suffix)
            hist = ticker.history(period='1d')
            return hist.empty
        except Exception:
            return True

    def resolve(self):
        df_unique = self.df[['ISIN', 'Symbol', 'Exchange']].drop_duplicates(subset=['Symbol'])
        isin_symbol_counts = df_unique.groupby('ISIN')['Symbol'].nunique()
        ambiguous_isins = isin_symbol_counts[isin_symbol_counts > 1].index
        ambiguous_symbols = df_unique[df_unique['ISIN'].isin(ambiguous_isins)]

        for _, group in ambiguous_symbols.groupby('ISIN'):
            symbols = list(group['Symbol'])
            exchanges = list(group['Exchange'])
            if len(symbols) < 2:
                continue
            s1, s2 = symbols[0], symbols[1]
            e1, e2 = exchanges[0], exchanges[1]
            suf1 = '.NS' if e1 == 'NSE' else '.BO' if e1 == 'BSE' else ''
            if self.is_delisted(s1, suf1):
                to_replace, replacement = s1, s2
            else:
                to_replace, replacement = s2, s1
            self.df.loc[self.df['Symbol'] == to_replace, 'Symbol'] = replacement
        return self.df


class StockSplitAdjuster:
    """Single Responsibility: Adjust trades for stock splits."""
    def __init__(self, df, split_json_path):
        self.df = df.copy()
        self.split_json_path = split_json_path

    def load_external_splits(self):
        try:
            with open(self.split_json_path, 'r') as f:
                raw = json.load(f)
        except Exception as e:
            print(f"Warning: Could not load split JSON: {e}")
            return pd.DataFrame(columns=['Symbol', 'Split Date', 'Split Ratio'])

        records = []
        for item in raw.get('Company_Ticker', []):
            if isinstance(item, dict):
                records.append({
                    'Symbol': item.get('symbol'),
                    'Split Date': pd.to_datetime(item.get('date'), dayfirst=True, errors='coerce'),
                    'Split Ratio': pd.to_numeric(item.get('stock_split'), errors='coerce')
                })
        return pd.DataFrame(records)

    def fetch_yfinance_splits(self):
        unique_syms = self.df[['Symbol', 'Exchange']].drop_duplicates()
        splits_list = []
        for _, row in unique_syms.iterrows():
            sym, exch = row['Symbol'], row['Exchange']
            ticker = f"{sym}.NS" if exch == 'NSE' else f"{sym}.BO" if exch == 'BSE' else sym
            try:
                splits = yf.Ticker(ticker).splits
                if splits.empty:
                    continue
                temp_df = splits.reset_index()
                temp_df.columns = ['Split Date', 'Split Ratio']
                temp_df['Symbol'] = sym
                temp_df['Exchange'] = exch
                splits_list.append(temp_df)
            except Exception as e:
                print(f"Warning: Could not fetch splits for {ticker}: {e}")

        if splits_list:
            df_splits = pd.concat(splits_list).reset_index(drop=True)
            df_splits['Split Date'] = pd.to_datetime(df_splits['Split Date']).dt.tz_localize(None)
            return df_splits
        else:
            return pd.DataFrame(columns=['Split Date', 'Split Ratio', 'Symbol', 'Exchange'])

    def adjust(self):
        external_splits = self.load_external_splits()
        yfinance_splits = self.fetch_yfinance_splits()

        external_splits['Split Date'] = pd.to_datetime(external_splits['Split Date'], errors='coerce').dt.tz_localize(None)
        yfinance_splits['Split Date'] = pd.to_datetime(yfinance_splits['Split Date'], errors='coerce').dt.tz_localize(None)

        combined_splits = pd.concat([yfinance_splits, external_splits], ignore_index=True, join='inner')
        combined_splits.drop_duplicates(subset=['Symbol', 'Split Date', 'Split Ratio'], inplace=True)
        combined_splits['Split Date'] = combined_splits['Split Date'].dt.normalize()

        self.df['Trade Date'] = pd.to_datetime(self.df['Trade Date'], errors='coerce').dt.tz_localize(None).dt.normalize()

        combined_splits = combined_splits.sort_values('Split Date')

        for _, split in combined_splits.iterrows():
            sym, split_date, ratio = split['Symbol'], split['Split Date'], split['Split Ratio']
            if pd.isna(sym) or pd.isna(split_date) or pd.isna(ratio):
                continue
            mask = (self.df['Symbol'] == sym) & (self.df['Trade Date'] < split_date)
            self.df.loc[mask, 'Quantity'] *= ratio
            self.df.loc[mask, 'Price'] /= ratio

        return self.df


class CashFlowCalculator:
    """Single Responsibility: Calculate cash flows for trades."""
    def __init__(self, df):
        self.df = df.copy()

    def calculate(self):
        self.df['Cash Flow'] = self.df.apply(
            lambda r: r['Quantity'] * r['Price'] if r['Trade Type'] == 'sell' else -r['Quantity'] * r['Price'], axis=1)
        return self.df


class XIRRCalculator:
    """Single Responsibility: Calculate XIRR for portfolio including current values."""
    def __init__(self, tradebook_df, external_price_path=None):
        self.df = tradebook_df
        self.external_price_path = external_price_path

    @staticmethod
    def _npv(rate, dates, cashflows):
        dates = [pd.to_datetime(d).tz_localize(None) if pd.to_datetime(d).tzinfo else pd.to_datetime(d) for d in dates]
        dates.sort()
        time_in_years = [(d - dates[0]).days / 365 for d in dates]
        return sum(cf / (1 + rate) ** ti for cf, ti in zip(cashflows, time_in_years))

    @staticmethod
    def _xirr(dates, cashflows):
        if not any(cf > 0 for cf in cashflows) or not any(cf < 0 for cf in cashflows):
            return None
        try:
            return newton(lambda r: XIRRCalculator._npv(r, dates, cashflows), x0=0.1, tol=1e-6, maxiter=100)
        except (RuntimeError, ValueError):
            return None

    def get_current_price(self, symbol, exchange):
        ticker_symbol = f'{symbol}.NS' if exchange == 'NSE' else f'{symbol}.BO' if exchange == 'BSE' else symbol
        try:
            ticker = yf.Ticker(ticker_symbol)
            info = ticker.info
            price = info.get('regularMarketPrice') or info.get('currentPrice') or info.get('previousClose')
            return price
        except Exception:
            return None

    def load_external_prices(self):
        if not self.external_price_path:
            return {}
        try:
            with open(self.external_price_path, 'r') as f:
                return json.load(f)
        except Exception:
            return {}

    def calculate(self):
        current_prices = {}
        external_prices = self.load_external_prices()

        for symbol, exch in self.df[['Symbol', 'Exchange']].drop_duplicates().values:
            price = self.get_current_price(symbol, exch)
            if price is None:
                price = external_prices.get(symbol)
            if price is not None:
                current_prices[symbol] = price
        current_prices.update(external_prices)

        self.df['signed_quantity'] = self.df.apply(lambda r: r['Quantity'] if r['Trade Type'] == 'buy' else -r['Quantity'], axis=1)
        holdings = self.df.groupby('Symbol')['signed_quantity'].sum()

        current_value = 0
        for sym, qty in holdings.items():
            if qty > 0:
                price = current_prices.get(sym)
                if price:
                    current_value += qty * price

        df_clean = self.df.dropna(subset=['Trade Date', 'Cash Flow'])
        dates = df_clean['Trade Date'].tolist()
        cashflows = df_clean['Cash Flow'].tolist()

        if current_value > 0 and dates:
            dates.append(pd.to_datetime(date.today()))
            cashflows.append(current_value)

        if not dates or not cashflows or len(dates) != len(cashflows):
            return None

        sorted_events = sorted(zip(dates, cashflows))
        sorted_dates, sorted_cashflows = zip(*sorted_events)

        result = self._xirr(list(sorted_dates), list(sorted_cashflows))
        return result * 100 if result is not None else None


# Usage example:
if __name__ == '__main__':
    try:
        ds = pd.read_csv('/content/TradeBook.csv')
    except Exception as e:
        print(f"Error loading CSV: {e}")
        ds = pd.DataFrame()

    if not ds.empty:
        preprocessor = DataPreprocessor(ds)
        ds1 = preprocessor.preprocess()

        resolver = SymbolResolver(ds1)
        ds2 = resolver.resolve()

        split_adjuster = StockSplitAdjuster(ds2, '/content/Stock_split_external.json')
        ds3 = split_adjuster.adjust()

        cash_flow_calc = CashFlowCalculator(ds3)
        ds4 = cash_flow_calc.calculate()

        xirr_calc = XIRRCalculator(ds4, '/content/external_stoc_current_price.json')
        portfolio_xirr = xirr_calc.calculate()

        if portfolio_xirr is not None:
            print(f"Portfolio XIRR: {portfolio_xirr:.2f}%")
        else:
            print("XIRR calculation failed.")
    else:
        print("TradeBook data unavailable or empty. Aborting.")

