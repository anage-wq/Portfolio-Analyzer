# -*- coding: utf-8 -*-
"""XIRR_for_indexes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zU0POQxnqFmMmUlvVhYbcrER4SemvtWr
"""

import pandas as pd
import yfinance as yf
from datetime import datetime, timedelta, date
from scipy.optimize import newton

tradebook = pd.read_csv("/content/TradeBook.csv")  # or any pandas DataFrame
securities = ['NIFTYBEES', 'BANKBEES', 'MID150BEES', 'HDFCSML250']
xirr_vals=[]

def calculate_xirr_with_current_prices_for_index_funds(tradebook_df, symbl):
    from scipy.optimize import newton
    from datetime import date
    import pandas as pd
    import yfinance as yf
    import pytz

    # --- Internal helper functions for NPV and XIRR ---
    def _npv(rate, dates, cashflows):
        """Calculate Net Present Value."""

        dates = [pd.to_datetime(d).tz_convert(None) if pd.to_datetime(d).tzinfo is not None else pd.to_datetime(d) for d in dates]


        dates.sort()
        if not dates:
            return 0.0

        time_in_years = [(d - dates[0]).days / 365.0 for d in dates]
        return sum(cf / (1 + rate) ** ti for cf, ti in zip(cashflows, time_in_years))


    def _xirr(dates, cashflows):
        """Calculate Extended Internal Rate of Return."""
        # Check if there are both positive and negative cash flows
        if not any(cf > 0 for cf in cashflows) or not any(cf < 0 for cf in cashflows):
            return None
        try:
            # Use Newton-Raphson method to find the root of the NPV equation.
            # Provide a range for the initial guess (x0) to help convergence
            # Adjust bounds as needed based on expected XIRR values
            return newton(lambda r: _npv(r, dates, cashflows), x0=0.1, tol=1e-6, maxiter=100)
        except RuntimeError:
            # Return None if solver does not converge.
            return None
        except ValueError:
            # Return None if input values are not appropriate (e.g., dates not unique)
            return None

    def get_current_stock_price(symbol: str) -> float:
        """
        Fetches the current market price of a stock from Yahoo Finance.

        Args:
            symbol (str): The stock ticker symbol (e.g., 'RELIANCE.NS', 'AAPL').

        Returns:
            float: The current market price, or None if not found.
        """
        try:
            stock = yf.Ticker(symbol)
            # The 'info' attribute contains a dictionary of stock information
            price = stock.info.get('regularMarketPrice')
            return price
        except Exception as e:
            print(f"Error fetching data for {symbol}: {e}")
            return None


    # --- 1. Get current stock price ---
    symbol_with_exchange = f"{symbl}.NS" if '.' not in symbl else symbl
    current_price = get_current_stock_price(symbol_with_exchange)

    if current_price is None:
        print(f"Could not fetch current price for {symbl}. Cannot calculate XIRR.")
        return None

    # --- 2. Calculate the total net quantity of the index fund ---
    # The input tradebook_df already represents the cash flows based on net quantity changes
    # The total net quantity is the sum of the 'Quantity' column in this DataFrame
    total_net_quantity = tradebook_df['Quantity'].sum()


    # --- 3. Calculate the value of current holdings ---
    current_portfolio_value = 0
    if total_net_quantity > 0:
        current_portfolio_value = total_net_quantity * current_price

    # --- 4. Prepare the final cash flow series ---

    # Get the original transaction cash flows and dates from the input DataFrame.
    # Ensure column names are consistent and use .loc for assignment
    df_cleaned = tradebook_df.dropna(subset=['Trade Date', 'Cash_Flow']).copy()
    dates = df_cleaned['Trade Date'].tolist()
    cashflows = df_cleaned['Cash_Flow'].tolist()


    # Add the current portfolio value as the final cash inflow event.
    # This represents the value you would get if you sold everything today.
    if current_portfolio_value > 0 and dates: # Also check if dates is not empty
        # Ensure today's date is timezone-naive
        today_naive = pd.to_datetime(date.today())
        dates.append(today_naive)
        cashflows.append(current_portfolio_value)
    elif current_portfolio_value == 0 and dates:
         # If current holding is zero, add a cashflow of 0 at today's date
         today_naive = pd.to_datetime(date.today())
         dates.append(today_naive)
         cashflows.append(0.0)



    # --- 5. Calculate and return XIRR ---
    # Ensure dates and cashflows are aligned and sorted by date for accurate XIRR
    # Combine dates and cashflows into a list of tuples and sort
    if not dates or not cashflows or len(dates) != len(cashflows):
        return None # Return None if cash flow data is not valid for XIRR calculation

    cashflow_events = sorted(zip(dates, cashflows))
    sorted_dates, sorted_cashflows = zip(*cashflow_events)

    xirr_value = _xirr(list(sorted_dates), list(sorted_cashflows))

    return xirr_value

def common(tradebook,sec):
  import pandas as pd
  from datetime import datetime
  tradebook['Trade Date'] = pd.to_datetime(tradebook['Trade Date'], dayfirst=True, errors='coerce', format='mixed')
  tradebook['Quantity'] = tradebook['Quantity'].astype(str).str.replace(',', '', regex=False)
  tradebook['Quantity'] = pd.to_numeric(tradebook['Quantity'], errors='coerce')
  tradebook['Trade Type'] = tradebook['Trade Type'].str.lower()
  total_quantity_by_date_and_type = tradebook.groupby(['Trade Date', 'Trade Type'])['Quantity'].sum()
  net_quantity_by_date = total_quantity_by_date_and_type.unstack(fill_value=0)
# Calculate net quantity as bought minus sold
  net_quantity_by_date['Net Quantity'] = net_quantity_by_date.get('buy', 0) - net_quantity_by_date.get('sell', 0)
  net_quantity_by_date.reset_index(inplace=True)
  net_quantity_by_date.drop(['buy','sell'],inplace=True,axis=1)
  all_dates=net_quantity_by_date['Trade Date']
  for i in sec:

    import yfinance as yf

    all_dates = pd.to_datetime(all_dates)

    ticker_symbol = i+'.NS'

    start_date = all_dates.min() - pd.Timedelta(days=10)
    end_date = all_dates.max() + pd.Timedelta(days=10)

    data = yf.download(ticker_symbol, start=start_date, end=end_date)

    closing_prices = data['Close'].reindex(all_dates)
    closing_prices.reset_index(inplace=True)
    closing_prices.rename(columns={i+'.NS': 'Price'}, inplace=True)
    closing_prices['Quantity']=net_quantity_by_date['Net Quantity']
    closing_prices['Cash_Flow']=(closing_prices['Quantity']*closing_prices['Price'])*-1
    xirr_vals.append(calculate_xirr_with_current_prices_for_index_funds(closing_prices, i)*100)



tradebook = pd.read_csv("/content/TradeBook.csv")  # or any pandas DataFrame
securities = ['NIFTYBEES', 'BANKBEES', 'MID150BEES', 'HDFCSML250']

common(tradebook,securities)


for i in range(0,4):
  print ( f'{securities[i]} XIRR value = {xirr_vals[i]}')

