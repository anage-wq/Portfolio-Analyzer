# -*- coding: utf-8 -*-
"""portfolio_vol&dd_preprocessing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mE3gYjNZVMx9Ibl8UpqDD5paBSmoDboi
"""



import pandas as pd
import numpy as np
from sklearn.preprocessing import FunctionTransformer
from sklearn.pipeline import Pipeline
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

import pandas as pd
import yfinance as yf
import json
from datetime import datetime, timedelta

# --- Utilities ---
def clean_quantity_and_price(df):
    df['Quantity'] = df['Quantity'].astype(str).str.replace(',', '', regex=False)
    df['Quantity'] = pd.to_numeric(df['Quantity'], errors='coerce')
    df['Price'] = df['Price'].astype(str).str.replace(',', '', regex=False)
    df['Price'] = pd.to_numeric(df['Price'], errors='coerce')
    return df

def to_lower_trade_type(df):
    df['Trade Type'] = df['Trade Type'].str.lower()
    return df

def read_json(filepath):
    with open(filepath, 'r') as f:
        return json.load(f)

# --- Core Logic ---
def calculate_symbol_quantities(df):
    uni_sym = df['Symbol'].unique()
    net_quantities = []
    for symbol in uni_sym:
        sub_df = df[df['Symbol'] == symbol]
        quantity = sub_df.apply(lambda row: row['Quantity'] if row['Trade Type'] == 'buy' else -row['Quantity'], axis=1).sum()
        net_quantities.append(quantity)
    return pd.DataFrame({'Symbol': uni_sym, 'Quantity': net_quantities})

def get_exchange_per_symbol(df, uni_sym):
    return [df[df['Symbol'] == symbol]['Exchange'].iloc[0] for symbol in uni_sym]

def fetch_last_close_prices(symbols, end_date):
    prices = []
    for symbol in symbols:
        ticker = f"{symbol}.NS"
        start_date = end_date - timedelta(days=50)
        data = yf.download(ticker, start=start_date, end=end_date)
        if not data.empty and len(data) >= 2:
            prices.append(data['Close'].iloc[-2])
        else:
            print(f"Could not fetch enough data for {ticker}. Appending None.")
            prices.append(None)
    return prices

def apply_additional_quantities(df, json_path):
    additional_quantity = read_json(json_path)
    df['Quantity'] = df.apply(
        lambda row: row['Quantity'] + additional_quantity.get(row['Symbol'], 0),
        axis=1
    )
    return df

# --- Main Combined Preprocessing ---
def full_preprocessing(ds, last_date_json='/content/Last_Date.json', additional_qty_json='/content/Additional_stock_quantity.json'):
    df = ds.copy()
    df.drop(['ISIN','Segment','Series','Auction','Trade ID','Order ID','Order Execution Time'],
            inplace=True, axis=1, errors='ignore')
    to_lower_trade_type(df)
    df['Trade Date'] = pd.to_datetime(df['Trade Date'], dayfirst=True, errors='coerce')
    clean_quantity_and_price(df)

    # Calculate net quantity
    symbol_df = calculate_symbol_quantities(df)
    uni_sym = symbol_df['Symbol'].tolist()

    # Add exchange info
    symbol_df['Exchange'] = get_exchange_per_symbol(df, uni_sym)

    # Add second-last closing price
    last_date_data = read_json(last_date_json)
    end_date = datetime.strptime(last_date_data['Date'], '%Y-%m-%d')
    symbol_df['Prices'] = fetch_last_close_prices(uni_sym, end_date)

    # Add additional quantities per symbol
    symbol_df = apply_additional_quantities(symbol_df, additional_qty_json)

    return symbol_df







