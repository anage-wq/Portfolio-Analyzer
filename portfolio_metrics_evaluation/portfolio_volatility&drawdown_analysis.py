# -*- coding: utf-8 -*-
"""portfolio_volatility&drawdown_analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1k1BSBM7YKL7L-lLnFBSzd4KbDzmWV_eK
"""

import pandas as pd
import numpy as np
import yfinance as yf
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

def calculate_volatility(prices):
    returns = prices.pct_change().dropna()
    volatility = returns.std() * np.sqrt(252)
    return volatility * 100

def calculate_max_drawdown(prices):
    cumulative = (1 + prices.pct_change()).cumprod()
    running_max = cumulative.expanding().max()
    drawdown = (cumulative - running_max) / running_max
    max_drawdown = drawdown.min()
    return max_drawdown * 100

def get_stock_data(symbol, period_days):
    try:
        ticker_symbol = f"{symbol}.NS"
        end_date = datetime.now()
        start_date = end_date - timedelta(days=period_days + 30)
        ticker = yf.Ticker(ticker_symbol)
        hist = ticker.history(start=start_date, end=end_date)
        if hist.empty or len(hist) < 10:
            return None
        hist = hist.tail(period_days) if len(hist) > period_days else hist
        return hist
    except Exception as e:
        print(f"Error fetching {symbol}: {str(e)}")
        return None

def analyze_individual_stock(symbol, period_days):
    hist = get_stock_data(symbol, period_days)
    if hist is None or hist.empty:
        return None, None
    volatility = calculate_volatility(hist['Close'])
    max_dd = calculate_max_drawdown(hist['Close'])
    return volatility, max_dd

def calculate_portfolio_metrics(portfolio_data, period_days):
    stock_prices = {}
    stock_returns = {}
    stock_weights = {}
    total_value = 0
    valid_stocks = []
    # Use "Quantity" column for consistency
    for idx, row in portfolio_data.iterrows():
        symbol = row['Symbol']
        # Now 'Quantity' is guaranteed to exist due to check in analyze_portfolio
        quantity = row['Quantity']
        hist = get_stock_data(symbol, period_days)
        if hist is not None and not hist.empty:
            current_price = hist['Close'].iloc[-1]
            stock_value = current_price * quantity
            total_value += stock_value
            stock_prices[symbol] = hist['Close']
            stock_returns[symbol] = hist['Close'].pct_change().dropna()
            valid_stocks.append({
                'Symbol': symbol,
                'Quantity': quantity,
                'CurrentPrice': current_price,
                'Value': stock_value
            })

    if total_value == 0 or not valid_stocks:
        return None, None, None, 0

    # Calculate weights
    for stock in valid_stocks:
        stock['Weight'] = stock['Value'] / total_value
        stock_weights[stock['Symbol']] = stock['Weight']

    returns_df = pd.DataFrame(stock_returns)
    returns_df = returns_df.dropna()
    if returns_df.empty:
        return None, None, None, total_value

    weights_series = pd.Series(stock_weights)
    portfolio_returns = (returns_df * weights_series).sum(axis=1)
    portfolio_volatility = portfolio_returns.std() * np.sqrt(252) * 100
    portfolio_cumulative = (1 + portfolio_returns).cumprod()
    running_max = portfolio_cumulative.expanding().max()
    drawdown = (portfolio_cumulative - running_max) / running_max
    portfolio_max_dd = drawdown.min() * 100

    return portfolio_volatility, portfolio_max_dd, valid_stocks, total_value

def analyze_portfolio(portfolio, periods):
    # Check if 'Quantity' column exists. If not, create a placeholder and inform the user.
    if 'Quantity' not in portfolio.columns:
        print("Warning: 'Quantity' column not found in the portfolio data. Assuming a quantity of 1 for each stock for now.")
        print("Please ensure your input CSV has a 'Quantity' column or update the code to use the correct column name for stock quantity.")
        portfolio['Quantity'] = 1 # Placeholder

    results = portfolio[['Symbol', 'Quantity']].copy()
    portfolio_metrics = {}
    # Initialize scores if needed
    wv = {}
    wdd = {}

    for period_name, days in periods.items():
        volatility_col = f'Volatility_{period_name}_%'
        drawdown_col = f'Max_Drawdown_{period_name}_%'
        results[volatility_col] = None
        results[drawdown_col] = None
        for idx, row in portfolio.iterrows():
            symbol = row['Symbol']
            vol, dd = analyze_individual_stock(symbol, days)
            if vol is not None and dd is not None:
                results.at[idx, volatility_col] = round(vol, 2)
                results.at[idx, drawdown_col] = round(dd, 2)

        # Pass the modified portfolio (with placeholder 'Quantity' if needed)
        p_vol, p_dd, stock_info, total_val = calculate_portfolio_metrics(portfolio, days)
        wv[period_name] = p_vol
        wdd[period_name] = p_dd
        if p_vol is not None:
            portfolio_metrics[period_name] = {
                'volatility': p_vol,
                'max_drawdown': p_dd,
                'total_value': total_val,
                'stock_info': stock_info
            }
    return results, portfolio_metrics, wv, wdd

def save_results(results, portfolio_metrics, periods):
    output_file = 'portfolio_analysis_individual_stocks.csv'
    results.to_csv(output_file, index=False)
    print(f"Individual stock results saved to: {output_file}")

    portfolio_summary = []
    for period_name, metrics in portfolio_metrics.items():
        portfolio_summary.append({
            'Period': period_name.replace('_', ' ').title(),
            'Portfolio_Volatility_%': round(metrics['volatility'], 2),
            'Portfolio_Max_Drawdown_%': round(metrics['max_drawdown'], 2),
            'Total_Portfolio_Value_â‚¹': round(metrics['total_value'], 2)
        })
    portfolio_df = pd.DataFrame(portfolio_summary)
    portfolio_output = 'portfolio_analysis_weighted_portfolio.csv'
    portfolio_df.to_csv(portfolio_output, index=False)
    print(f"Portfolio-level results saved to: {portfolio_output}")
    return portfolio_df

def main():
    # Use preprocessed/combined portfolio DataFrame
    portfolio = pd.read_csv('/content/Final_portfolio_with_price (1).csv')
    print("Columns in portfolio DataFrame:", portfolio.columns.tolist())

    periods = {
        '3_months': 90,
        '6_months': 180,
        '1_year': 365
    }
    results, portfolio_metrics, wv, wdd = analyze_portfolio(portfolio, periods)
    portfolio_df = save_results(results, portfolio_metrics, periods)

    print("\nSUMMARY - INDIVIDUAL STOCKS")
    for period_name in periods.keys():
        vol_col = f'Volatility_{period_name}_%'
        dd_col = f'Max_Drawdown_{period_name}_%'
        print(f"\n{period_name.replace('_', ' ').title()}:")
        print(f"  Average Volatility: {results[vol_col].mean():.2f}%")
        print(f"  Average Max Drawdown: {results[dd_col].mean():.2f}%")
        max_vol_idx = results[vol_col].idxmax()
        min_dd_idx = results[dd_col].idxmin()
        if pd.notna(max_vol_idx):
            print(f"  Highest Volatility: {results.loc[max_vol_idx, vol_col]:.2f}% ({results.loc[max_vol_idx, 'Symbol']})")
        if pd.notna(min_dd_idx):
            print(f"  Worst Drawdown: {results.loc[min_dd_idx, dd_col]:.2f}% ({results.loc[min_dd_idx, 'Symbol']})")

    print("\nSUMMARY - WEIGHTED PORTFOLIO")
    print(portfolio_df.to_string(index=False))

    # Show holdings by weight from most recent period's metrics
    if portfolio_metrics:
        last_period = list(portfolio_metrics.keys())[-1]
        stock_info = portfolio_metrics[last_period]['stock_info']
        print("\nHOLDINGS BY WEIGHT")
        stock_info_df = pd.DataFrame(stock_info).sort_values('Weight', ascending=False)
        stock_info_df['Weight_%'] = (stock_info_df['Weight'] * 100).round(2)
        print(stock_info_df[['Symbol', 'Quantity', 'CurrentPrice', 'Value', 'Weight_%']].to_string(index=False))
    return results, portfolio_df

if __name__ == "__main__":
    results, portfolio_summary = main()

